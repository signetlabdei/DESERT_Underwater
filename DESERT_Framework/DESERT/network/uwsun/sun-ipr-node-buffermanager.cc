//
// Copyright (c) 2012 Regents of the SIGNET lab, University of Padova.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University of Padova (SIGNET lab) nor the 
//    names of its contributors may be used to endorse or promote products 
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED 
// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
// OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
// OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF 
// ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/**
 * @file   sun-ipr-node-buffermanager.cc
 * @author Giovanni Toso
 * @version 1.1.1
 * 
 * \brief Provides the implementation of all the methods regarding Buffer Management.
 *
 * Provides the implementation of all the methods regarding Buffer Management.
 */

#include "sun-ipr-node.h"

extern packet_t PT_SUN_ACK;
extern packet_t PT_SUN_DATA;
extern packet_t PT_SUN_PATH_EST;
extern packet_t PT_SUN_PROBE;

/* Timer. It is invoked automatically when the timer on a sink probe expires. 
 */
void BufferTimer::expire(Event* e) {
    module->bufferManager();
} /* BufferTimer::expire */

void SunIPRoutingNode::bufferManager() {
    if (STACK_TRACE)
        cout << "> bufferManager()" << endl;
    double delay_tx_ = this->getDelay(period_data_);
    if (buffer_data.size() >= 1) { // There is at least 1 pkt in the buffer.
        buffer_element _tmp = buffer_data.front(); // Pointer to the first element in the buffer.
        if (_tmp.num_retx_ < max_ack_error_) { // The first pkt is valid.
            Packet* p = _tmp.p_->copy();
            
            hdr_cmn* ch         = HDR_CMN(p);
            hdr_uwip* iph       = HDR_UWIP(p);
            hdr_sun_data* hdata = HDR_SUN_DATA(p);
            
//            cout << printIP(ipAddr_) << ":hc:" << this->getNumberOfHopToSink() << ":destination:" << printIP(iph->daddr()) << ":source:" << printIP(iph->saddr()) << endl;
//            cout << "--->";
//            for (int i = 0; i < hdata->list_of_hops_length(); i++) {
//                cout << printIP(hdata->list_of_hops()[i]) << "-";
//            }
//            cout << endl;
//            cout << "---#";
//            for (int i = 0; i < hop_table_length; i++) {
//                cout << printIP(hop_table[i]) << "-";
//            }
//            cout << endl;
            
            if (this->getNumberOfHopToSink() == 1) {
                if (iph->daddr() == 0) { // The packet is not initialized.
                    this->initPktDataPacket(p);
                    _tmp.num_retx_++;
                    _tmp.t_last_tx_ = Scheduler::instance().clock();
                    ch->next_hop()      = sink_associated;
                    iph->daddr()        = sink_associated;
                    _tmp.p_ = p->copy();
                    Packet::free(((buffer_element) buffer_data.front()).p_);
                    buffer_data.erase(buffer_data.begin());
                    buffer_data.insert(buffer_data.begin(), _tmp);
                    number_of_datapkt_++;
                    data_and_hops[0]++; // The node is directly connected to the sink, the hop count is 1; In the stats this value can be less or equal to the number of packet generated by the Application of this node. This because the buffer can be full.
                    pkt_tx_++;
                    if (trace_)
                        this->tracePacket(_tmp.p_, "SEND_DTA");
                    ch->prev_hop_ = ipAddr_;
                    sendDown(_tmp.p_->copy(), delay_tx_);
                } else { // The packet was previously initialized.
                    _tmp.num_retx_++;
                    _tmp.t_last_tx_ = Scheduler::instance().clock();
                    ch->next_hop()      = sink_associated;
                    iph->daddr()        = sink_associated;
                    _tmp.p_ = p->copy();
                    buffer_data.erase(buffer_data.begin());
                    buffer_data.insert(buffer_data.begin(), _tmp);
                    if (iph->saddr() != ipAddr_) {
                        number_of_pkt_forwarded_++;
                    }
                    number_of_datapkt_++;
                    pkt_tx_++;
                    if (trace_)
                        this->tracePacket(_tmp.p_, "SEND_DTA");
                    ch->prev_hop_ = ipAddr_;
                    sendDown(_tmp.p_->copy(), delay_tx_);
                }
            } else if (this->getNumberOfHopToSink() == 0) {
                if (search_path_enable_) {
                    this->searchPath(); // Node not connected with any sink: send a path establishment request.
                    search_path_enable_ = false;
                    searchPathTmr_.resched(timer_search_path_);
                }
                if (iph->daddr() == 0) { // The packet is not initialized and the current node doesn't have any path to the sink: wait.
                    _tmp.num_retx_++;
                    _tmp.t_last_tx_ = Scheduler::instance().clock();
                    _tmp.p_ = p->copy();
                    Packet::free(((buffer_element) buffer_data.front()).p_);
                    buffer_data.erase(buffer_data.begin());
                    buffer_data.insert(buffer_data.begin(), _tmp);
                } else {
                    if (iph->saddr() == ipAddr_) { // The current node created a packet but now it doesn't have a path to the sink -> reset the packet.
                        iph->daddr() = 0;
                        _tmp.num_retx_++;
                        _tmp.t_last_tx_ = Scheduler::instance().clock();
                        _tmp.p_ = p->copy();
                        Packet::free(((buffer_element) buffer_data.front()).p_);
                        buffer_data.erase(buffer_data.begin());
                        buffer_data.insert(buffer_data.begin(), _tmp);
                        pkt_tx_++;
                    } else { // Otherwise forward.
                        _tmp.num_retx_++;
                        _tmp.t_last_tx_ = Scheduler::instance().clock();
                        _tmp.p_ = p->copy();
                        Packet::free(((buffer_element) buffer_data.front()).p_);
                        buffer_data.erase(buffer_data.begin());
                        buffer_data.insert(buffer_data.begin(), _tmp);
                        this->forwardDataPacket(_tmp.p_->copy());
                    }
                }
            } if (this->getNumberOfHopToSink() > 1) {
                if (iph->daddr() == 0) { // The packet is not initialized.
//                    cout << "node:" << printIP(ipAddr_) << "-bufsize:" << buffer_data.size() << "-hop:" << this->getNumberOfHopToSink() << "-init." << endl;
                    this->initPktDataPacket(p);
                    ch->next_hop()      = this->hop_table[0];
                    iph->daddr()        = sink_associated;
                    number_of_datapkt_++;
                    _tmp.num_retx_++;
                    _tmp.t_last_tx_ = Scheduler::instance().clock();
                    _tmp.p_ = p->copy();
                    Packet::free(((buffer_element) buffer_data.front()).p_);
                    buffer_data.erase(buffer_data.begin());
                    buffer_data.insert(buffer_data.begin(), _tmp);
                    data_and_hops[int(hdata->list_of_hops_length())]++;
                    pkt_tx_++;
                    if (trace_)
                        this->tracePacket(_tmp.p_, "SEND_DTA");
                    ch->prev_hop_ = ipAddr_;
                    sendDown(_tmp.p_->copy(), delay_tx_);
                } else {
//                    cout << "node:" << printIP(ipAddr_) << "-bufsize:" << buffer_data.size() << "-hop:" << this->getNumberOfHopToSink() << "-send." << endl;
                    _tmp.num_retx_++;
                    _tmp.t_last_tx_ = Scheduler::instance().clock();
                    _tmp.p_ = p->copy();
                    Packet::free(((buffer_element) buffer_data.front()).p_);
                    buffer_data.erase(buffer_data.begin());
                    buffer_data.insert(buffer_data.begin(), _tmp);
                    if (iph->saddr() == ipAddr_) { // Send.
                        number_of_datapkt_++;
                        pkt_tx_++;
                        if (trace_)
                            this->tracePacket(_tmp.p_, "SEND_DTA");
                        ch->prev_hop_ = ipAddr_;
                        sendDown(_tmp.p_->copy(), delay_tx_);
                    } else { // Otherwise forward.
                        this->forwardDataPacket(_tmp.p_->copy());
                    }
                }
            }
            Packet::free(p);
        } else { // The first packet in the buffer is invalid.
            Packet* p = _tmp.p_->copy();
            hdr_cmn* ch         = HDR_CMN(p);
            hdr_uwip* iph       = HDR_UWIP(p);
            if (iph->saddr() == ipAddr_) { // Current node creates the packet that generated an error: remove the routing information.
                this->clearHops();
                this->setNumberOfHopToSink(0);
            } else { // Another node created the packet: create a route error packet.
                if (!disable_path_error_) {
                    Packet* p_error = Packet::alloc();
                    this->createRouteError(p, p_error);
                    
                    if (ch->next_hop() == this->sink_associated) {
                        this->clearHops();
                        this->setNumberOfHopToSink(0);
                    } else if (ch->next_hop() != 0 && ch->next_hop() == hop_table[0]) { // If the next hop of the packet that generated an error is equal to the next hop of the current node: update the routing information.
                        this->clearHops();
                        this->setNumberOfHopToSink(0);
                    }
                    if (trace_)
                        this->tracePacket(p_error, "SEND_ERR");
                    ch->prev_hop_ = ipAddr_;
                    sendDown(p_error->copy());
                    Packet::free(p_error);
                }
            }
            number_of_drops_maxretx_++;
            Packet::free(((buffer_element) buffer_data.front()).p_);
            buffer_data.erase(buffer_data.begin()); // Remove the first pkt.
            Packet::free(p);
            if (reset_buffer_if_error_) { // If == 1 all the packets in the buffer will be removed.
                while(!buffer_data.empty()) {
                    Packet::free(((buffer_element) buffer_data.front()).p_);
                    buffer_data.erase(buffer_data.begin());
                }
            }
        }
    }
    bufferTmr_.resched(timer_buffer_ + delay_tx_);
    return;
}